#include <string>

#include <iostream>

using namespace std;

struct STUDENT

{
    int age;
    string name;
    void move() {
        cout << name << " is moving" << endl;
    }
};


class Person
{


    public:
    int age;
     string name;
  //  int& ageRef;const string name;
    /*    Этот класс не будет компилироваться, так как здесь есть две ошибки - отсутствие инициализации константы name и ссылки ageRef.
         Хотяя их значения устанавливаются в конструкторе, но к моменту, когда код инструкции из тела конструктора начнут выполняться, константы и ссылки уже должны быть инициализированы.
         И для этого необходимо использовать списки инициализации .
         Списки инициализации представляют перечисления инициализаторов для каждой из переменных и констант через двоеточие после списка параметров конструктора
         */

   

  
 
//является спецификатором доступа (access specifier), то есть определяет параметры доступа к членам класса - переменным и функциям.
//По сути спецификатор public определяет общедоступный интерфейс класса.
    Person(string n, int a)
    {
        name = n; age = a;
    }
    void move()
    {
        cout << name << " is moving" << endl;
    }
    void setAge(int a)
    {
        if (a > 0 && a < 100) age = a;
    }
    string getName()
    {
        return name;
    }
    int getAge()
    {
        return age;
    }
};


  
   // string name;
    //int age;
   /* Person(string n, int a) // КОНСТРУКТОР
    {
        name = n; age = a;//Конструктор представляет функцию, которая может принимать параметры и которая должна называться по имени класса. 
        //В данном случае конструктор принимает два параметра и передает их значения полям name и age.
    }
   
    void move()// Обычная функция
    {
        cout << name << " is not moving" << endl;
    }
    */

class Person2 : public Employee//Наследование
{
public:
    std::string name2;       //  имя
    int age2;                // возраст
    void display2()
    {
        std::cout << "Name: " << name2 << "\tAge: " << age2 << std::endl;
    }
};
class Employee 
{
public:
    std::string company;    // компания
};

int main()
{
    Person2 tom;
    tom.name2 = "Tom";
    tom.age2 = 23;
    tom.display2();

    Person2 bob;
    bob.name2 = "Bob";
    bob.age2 = 31;
    bob.company = "Microsoft";
    bob.display2();






    STUDENT student;
    STUDENT* ptr = &student;
    ptr->name = "John";
    ptr->age = 42;
    cout << "Name: " << ptr->name << "\tAge: " << ptr->age << endl;
    ptr->move();


   
  /*  Person person = Person("Tom", 22);
    // или Person person("Tom", 22);
    cout << "Name: " << person.name << "\tAge: " << person.age << endl;
    person.name = "Bob";
    person.move();
    */
    // string personName = tom.name;    // ошибка - переменная name закрытая
    Person Jack("Tom", 22);
    cout << "Name: " << Jack.name << "\tAge: " << Jack.age << endl;
    Jack.move();
    return 0;

    return 0;

 
    return 0;

}
/*В классах есть наследование*/
/*Структуры по умолчанию являются открытыми (public). Тогда как в классе все его члены, для которых не указан спецификатор доступа, являются закрытыми (private).*/
/*Когда использовать структуры? Как правило, структуры используются для описания таких данных, которые имеют только набор публичных атрибутов - открытых переменных.
Иногда подобные сущности еще называют аггрегатными классами (aggregate classes).*/

/*Класс – является ссылочным типом , а структуры – значимым типом  . 
Следовательно, классы всегда создаются в так называемой “куче” (heap), а структуры создаются в стеке (stack).*/
/*Структуры, указываемые в списке параметров метода, передаются по значению (то есть копируются), объекты классов — по ссылке. 
Именно это является главным различием в их поведении, а не то, где они хранятся. */
/*      Типы значений:

Целочисленные;
С плавающей запятой;
Десятичный;
Логический;
Структуры;
Перечисления.

        Ссылочные типы:

Объекты;
Строки;
Классы;
Интерфейсы;
Делегаты.
Разница между ними в том, что типы значений хранят данные, а ссылочные типы – это ссылки на данные.
Их переменные размещаются в разных областях памяти, выделенной для программы, именуемых стеком (stack) и кучей (heap).*/
/*public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок.

private: закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.

protected: такой член класса доступен из любого места в текущем классе или в производных классах. При этом производные классы могут располагаться в других сборках.

internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).

protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.

private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.*/